
JavaScript — **асинхронный однопоточный** язык, но браузер предоставляет **API**, который распределяет вызовы по очередям.

Существует два типа задач:

- **Microtasks (микрозадачи)**
    
- **Macrotasks (макрозадачи)**
    

### **Как работает Event Loop?**

Это **бесконечный цикл**, который ожидает события и обрабатывает их.

1. **Microtasks** (высший приоритет):
    
    - Обрабатываются **первыми** в рамках текущего тика Event Loop.
        
    - Сюда попадают:
        
        - Промисы (`Promise`)
            
        - `async/await`
            
        - `queueMicrotask()`
            
2. **Macrotasks** (низший приоритет):
    
    - Выполняются **после** всех микрозадач.
        
    - Сюда попадают:
        
        - `setTimeout`, `setInterval`
            
        - `requestAnimationFrame`
            
        - I/O-операции
            

### **Порядок выполнения**

1. Выполняется **синхронный код** (если есть).
    
2. Обрабатываются **все микрозадачи** (если они есть в очереди).
    
3. Выполняется **одна макрозадача** (если есть).
    
4. Цикл повторяется.

- Если во время выполнения макрозадачи появляются новые микрозадачи, они будут обработаны **сразу**, прежде чем Event Loop перейдет к следующей макрозадаче.
    
- Несмотря на асинхронность, JavaScript **гарантирует порядок выполнения** благодаря приоритету микрозадач.
- 

https://www.jsv9000.app/



Node.js использует **6 фаз** Event Loop (реализация через библиотеку `libuv`). Они выполняются в строгом порядке, и каждая фаза обрабатывает свой тип задач.

## **1. Timers (Таймеры)**

**Что обрабатывает:**

- Коллбэки `setTimeout()` и `setInterval()`.
    

**Как работает:**

- Проверяет, истек ли таймер.
    
- Выполняет коллбэки, чьё время вышло.
    

⚠️ **Важно:**

- Таймеры **не гарантируют точное время** выполнения (задержка возможна из-за других фаз).
    
- `setImmediate()` здесь **не выполняется** (это следующая фаза).

## **2. Pending Callbacks (Отложенные коллбэки)**

**Что обрабатывает:**

- Системные операции (например, ошибки сети, `TCP ECONNREFUSED`).

```js 
const socket = net.connect(80, 'nonexistent-host');
socket.on('error', (err) => console.log('Ошибка!')); // Выполнится здесь
```


## **3. Idle, Prepare (Внутренние операции)**

Фаза для внутренних процессов Node.js (обычно не используется в коде).

## **4. Poll (Опрос новых событий)**

**Самая важная фаза** (здесь тратится больше всего времени).

**Что делает:**

1. **Проверяет I/O-коллбэки** (например, ответы от сервера, чтение файлов).
    
2. **Если очередь пуста:**
    
    - Ждёт новые задачи (например, входящие HTTP-запросы).
        
    - Может перейти к `setImmediate()`, если есть такие задачи.
        

**Пример:**

```js 
fs.readFile('file.txt', () => {
  console.log('I/O завершён!'); // Выполнится здесь
});
```


## **5. Check (`setImmediate`)**

**Что обрабатывает:**

- Коллбэки `setImmediate()`.
    

**Отличие от `setTimeout(..., 0)`:**

|`setImmediate()`|`setTimeout(..., 0)`|
|---|---|
|Выполняется в **фазе Check**|Выполняется в **фазе Timers**|
|Быстрее при **запуске внутри I/O-цикла**|Медленнее в этом случае|

```js 
fs.readFile('file.txt', () => {
  setTimeout(() => console.log('Timeout'), 0);  
  setImmediate(() => console.log('Immediate')); // Выполнится первым!
});
```

## **6. Close Callbacks (Закрытие соединений)**

**Что обрабатывает:**

- События `'close'` (например, `socket.on('close', ...)`).
    

**Пример:**

```js 
const server = net.createServer();
server.on('connection', (socket) => {
  socket.on('close', () => console.log('Соединение закрыто!')); // Здесь
});
```

### **Вывод**

- **Event Loop в Node.js сложнее, чем в браузере** (6 фаз против одной очереди).
    
- **`setImmediate` vs `setTimeout(0)`** — разница видна только внутри I/O-операций.
    
- **Микрозадачи (`Promise`, `nextTick`)** имеют приоритет над макрозадачами.
    

Если нужно запомнить:

> **"Timers → Pending → Poll → Check → Close, а `nextTick` и Промисы — везде!"**

Полезно для оптимизации асинхронного кода и дебага сложных сценариев. 🚀