
**TypeScript** - дает более крепкий и самодокументируемый код тк мы описываем все входящие аргументы функции и ее типы, описываем что ф-я возвращает , посе этого когда повторно возвращаемся к коду в нем легче разобарться, так же новому человеку в команде будет проще ориентироваться , в обычном js даже если задокументировать весь код через JsDoc все равно придется просматривать все зависимости и места где этот компонент используется, так же предотвращает часть возможных ошибок когда разработчик может что-то забыть передать в компонент или передаст данные неправильного типа

**Мемоизация**  — это кэширование результата функции, чтобы последующие вызовы могли использовать этот кэшированный результат без лишних вычислений.

# JS base

**1) разница между null / undefined / undeclared**

- null - означает отсутствие какого либо значения
- undefined - если значение не присвоено
- `у примитивов, как таковых, не может быть свойств вообще, они есть только у объектов. А при попытке получить свойство у примитива, он будет неявно преобразован в объект. В этом легко убедиться:`

```js
const myString = ‘String’

// Вернет undefined

myString.someProp

typeof(null) // Вернет 'object'

```

Любая объявленная переменная, которой при создании не присвоено никакого значения, имеет значение `undefined`

Спецификация описывает эти значения следующим образом: `undefined` используется как значение по умолчанию в неинициализированных переменных; `null` используется как значение, которое явно устанавливается разработчиком как признак отсутствия любого объектного значения.

Значение `undefined` также получается при попытке обратиться к несуществующему свойству объекту или элементу массива:

# DOM

**В чем отличие document.querySelectorAll() от document.getElementsByClassName()?**

В первом случае HTMLCollection, во втором NodeList. Отличие первой от второго

[**состоит в том, что**](https://developer.mozilla.org/ru/docs/Web/API/HTMLCollection)

> HTMLCollection, хранящая элементы DOM, является динамической. При изменении документа она моментально отражает все произведённые изменения.


Как работает механизм batching в React и что изменилось в React 18?
2. Что происходит, если useEffect не имеет зависимостей?
3. Что происходит в React при обновлении ключа key у компонента?
4. Почему не стоит использовать index как key в списках?
5. Как работает Forward Refs и когда он необходим?
6. Когда стоит использовать useReducer вместо useState?
7. Почему важно, чтобы хуки вызывались в одинаковом порядке?
8. Как организовать FSD архитектуре?
9. Как работает Event loop?
10. web workers/ service workers
11. методы promis-ов