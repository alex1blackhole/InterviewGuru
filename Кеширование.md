Кеширование — это критически важный механизм оптимизации производительности веб-приложений, позволяющий уменьшить нагрузку на сервер, снизить задержки и ускорить загрузку для пользователей. В контексте фронтенда кеширование применяется на разных уровнях: от браузерного кеширования ресурсов до стратегий управления состоянием приложения.

---

## **1. Браузерное кеширование (HTTP Caching)**

Браузеры используют HTTP-кеширование для хранения статических ресурсов (CSS, JS, изображения, шрифты).

### **Механизмы HTTP-кеширования:**

- **Cache-Control** – основной HTTP-заголовок, управляющий кешированием:
    
    - `max-age=<seconds>` – время жизни кеша (например, `max-age=3600`).
        
    - `no-cache` – требует валидации с сервером перед использованием кеша.
        
    - `no-store` – полностью отключает кеширование.
        
    - `public` / `private` – определяет, можно ли кешировать ресурс в CDN или только у клиента.
        
- **ETag / Last-Modified** – механизмы валидации кеша:
    
    - Сервер возвращает `ETag` (хеш ресурса) или `Last-Modified` (дата изменения).
        
    - При повторном запросе браузер отправляет `If-None-Match` (ETag) или `If-Modified-Since` (Last-Modified).
        
    - Если ресурс не изменился, сервер отвечает `304 Not Modified`, и браузер использует кеш.
        

### **Практическое применение:**

```php
Cache-Control: public, max-age=31536000, immutable  # Для статики (хешированные файлы)
Cache-Control: no-cache                            # Для динамических данных
```


**Проблемы и решения:**

- **Инвалидация кеша** – использование хешей в именах файлов (`main.a1b2c3.js`).
    
- **Кеширование API-запросов** – можно через `Service Worker` или библиотеки (React Query, SWR).
    

---

## **2. Кеширование в Service Workers (PWA, Offline First)**

Service Worker (SW) позволяет перехватывать сетевые запросы и управлять кешем на уровне клиента.

### **Стратегии кеширования в SW:**

1. **Cache First** – сначала проверяет кеш, потом сеть (подходит для статики).
    
2. **Network First** – сначала запрос к сети, при ошибке – кеш (для динамических данных).
    
3. **Stale-While-Revalidate** – отдаёт кеш, но фоново обновляет его.
    
4. **Precaching** – предзагрузка критических ресурсов при установке SW.
    

**Пример (Workbox):**

```js
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';

// Кеширование статики
registerRoute(
  ({ request }) => request.destination === 'style' || request.destination === 'script',
  new CacheFirst({ cacheName: 'static-assets' })
);

// Кеширование API
registerRoute(
  ({ url }) => url.pathname.startsWith('/api'),
  new NetworkFirst({ cacheName: 'api-cache' })
);
```

**Проблемы:**

- **Сложность инвалидации** – нужно версионировать кеш (`cacheName: 'v2'`).
    
- **Ограничения хранилища** – `navigator.storage.estimate()` для мониторинга.
    

---

## **3. Кеширование данных приложения (Client-Side State)**

В современных SPA-фреймворках (React, Vue, Angular) кеширование данных на клиенте уменьшает количество запросов к API.

### **Библиотеки для кеширования:**

- **React Query / SWR** – автоматически кешируют данные, поддерживают фоновое обновление.


```js
const { data } = useQuery(['todos'], fetchTodos, { staleTime: 5000 });
```

- **Apollo Client (GraphQL)** – нормализованный кеш.
    
- **Redux (RTK Query) / MobX** – ручное управление состоянием.
    

**Оптимизации:**

- **Дедупликация запросов** – избегание дублей при параллельных запросах.
    
- **Оптимистичные обновления** – мгновенное отображение изменений до ответа сервера.
    

---

## **4. CDN и Edge Caching**

Для глобального ускорения контента используются CDN (Cloudflare, Akamai), которые кешируют статику и даже SSR-ответы (Next.js, Nuxt).

**Стратегии:**

- **Static Asset Caching** – длительный TTL для хешированных файлов.
    
- **Edge Side Includes (ESI)** – частичное кеширование динамических страниц.
    

---

## **5. Проблемы и Best Practices**

- **Кеширование API:**
    
    - Для мутаций (`POST/PUT`) – сброс кеша.
        
    - Для `GET` – короткий `staleTime` (React Query) или `max-age` (Cache-Control).
        
- **Инвалидация:**
    
    - По событию (WebSocket, Server-Sent Events).
        
    - По таймеру (например, `staleTime: 60_000`).
        
- **Размер кеша:**
    
    - Очистка старых данных (например, `workbox-expiration`).
        
    - Использование `IndexedDB` для больших данных.
        

---

## **Вывод**

Эффективное кеширование требует комбинации подходов:

1. **Браузерный кеш** – для статики.
    
2. **Service Worker** – для офлайн-работы.
    
3. **Клиентское состояние** – для данных приложения.
    
4. **CDN** – для глобальной доставки.
    

Грамотная настройка кеширования может ускорить загрузку на 50-80%, снизить нагрузку на сервер и улучшить UX.
