	

**Принципы ООП: - Абстракция - Инкапсуляция - Наследование - Полиморфизм**

принцип единственной ответственности

принцип открытости / закрытости

принцип подстановки Барбары Лисков

принцип разделения интерфейса

принцип инверсии зависимостей

**наследование** для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя все остальное, учтенное на предыдущих шагах;

абстрагирование для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счете — контекстное понимание предмета, формализуемое в виде класса;

инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;

полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.

**прототипное наследование**

Все объекты в JavaScript имеют свойство `prototype` , которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее [делегирование, чем наследование](https://davidwalsh.name/javascript-objects) .

**proto** — это свойство любого объекта в JS, которое является ссылкой на свойство prototype функции-конструктора:

**prototype** — это свойство функции-конструктора, которое хранит поведение наследуемое потомками:

- у каждой функции в JS есть свойство prototype, но только у функций! Класс в JS — это синтаксический сахар вокруг функции-конструктора, следовательно, у классов тоже есть свойство prototype.
- Потомок связан с родителем свойством **proto**, которое указывает на свойство prototype родителя, в котором в свою очередь хранится своя ссылка **proto**, указывающая на его родителя. Такая связь называется цепочка прототипов, а сам механизм такого наследования называется прототипное наследование.