
## 🔍 **Основы useMemo**

**useMemo** — это хук для мемоизации (кэширования) вычислений между рендерами:

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### Как это работает:

1. **При первом рендере** — вычисляет и сохраняет результат
    
2. **При последующих рендерах**:
    
    - Возвращает кэшированное значение, если зависимости не изменились
        
    - Пересчитывает, если зависимости изменились
        

## 💡 **Когда использовать useMemo**

### 1. Тяжелые вычисления

```js
function ExpensiveComponent({ items }) {
  const sortedItems = useMemo(() => {
    console.log('Сортировка...');
    return items.sort((a, b) => a.value - b.value);
  }, [items]);

  return <List items={sortedItems} />;
}
```

### 2. Оптимизация дочерних компонентов

```js
function Parent({ a, b }) {
  const childProps = useMemo(() => ({ a, b }), [a, b]);
  
  return <Child {...childProps} />; // Child не будет перерендериваться без изменений
}
```

### 3. Мемоизация объектов/массивов

```js
const config = useMemo(() => ({
  color: darkMode ? 'dark' : 'light',
  size: 'large'
}), [darkMode]);
```

## 🆚 **Сравнение с похожими хуками**

|Характеристика|useMemo|useCallback|useEffect|
|---|---|---|---|
|**Назначение**|Кэширование значений|Кэширование функций|Побочные эффекты|
|**Возвращает**|Любое значение|Функцию|-|
|**Зависимости**|Да|Да|Да|

## ⚠️ **Распространенные ошибки**

1. **Излишнее использование**:

```js
// Плохо (простое вычисление не требует мемоизации)
const total = useMemo(() => a + b, [a, b]);

// Хорошо
const total = a + b;
```

2. **Пустой массив зависимостей**:

```js
// Плохо (может привести к багам)
const value = useMemo(() => compute(a), []);
```

3. **Мемоизация примитивов**:

```js
// Бесполезно (примитивы и так сравниваются по значению)
const memoizedString = useMemo(() => 'hello', []);
```

## 🏆 **Продвинутые примеры**

### 1. Оптимизация сортировки таблицы

```js
function DataTable({ data, sortKey }) {
  const sortedData = useMemo(() => {
    return [...data].sort((a, b) => 
      a[sortKey] > b[sortKey] ? 1 : -1
    );
  }, [data, sortKey]);

  return <Table data={sortedData} />;
}
```


### 2. Мемоизация компонентов

```js 
const MemoizedComponent = useMemo(() => 
  () => <ExpensiveComponent prop={value} />, 
[value]);
```

## 📊 **Когда действительно нужно использовать useMemo?**

✔ **Тяжелые вычисления** (фильтрация, сортировка больших массивов)  
✔ **Создание объектов/массивов**, передаваемых в оптимизированные компоненты  
✔ **Когда рендер дороже сравнения зависимостей**

## 🚀 **Вывод**

**useMemo** — это мощный инструмент оптимизации, который следует использовать осознанно:

1. **Не применяйте** для простых вычислений
    
2. **Используйте** для предотвращения дорогостоящих пересчетов
    
3. **Помните**, что сравнение зависимостей тоже имеет стоимость

```js 
// Правильное использование
const optimizedValue = useMemo(() => 
  expensiveCalculation(dep1, dep2), 
[dep1, dep2]);
```

